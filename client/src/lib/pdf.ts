import { Book } from "@shared/schema";
import { jsPDF } from "jspdf";
import { toast } from "@/hooks/use-toast";

// Helper function to add an image to the PDF
const addImageToPdf = async (doc: jsPDF, imageUrl: string, x: number, y: number, width: number, height: number): Promise<void> => {
  return new Promise((resolve, reject) => {
    try {
      const img = new Image();
      img.crossOrigin = "Anonymous";
      
      img.onload = () => {
        try {
          const canvas = document.createElement("canvas");
          canvas.width = img.width;
          canvas.height = img.height;
          
          const ctx = canvas.getContext("2d");
          if (!ctx) {
            reject(new Error("Could not get canvas context"));
            return;
          }
          
          ctx.drawImage(img, 0, 0);
          const imgData = canvas.toDataURL("image/jpeg");
          
          doc.addImage(imgData, "JPEG", x, y, width, height);
          resolve();
        } catch (err) {
          console.error("Error processing loaded image:", err);
          resolve(); // Continue without the image rather than rejecting
        }
      };
      
      img.onerror = (err) => {
        console.error("Error loading image:", err);
        resolve(); // Continue without the image
      };
      
      img.src = imageUrl;
    } catch (err) {
      console.error("Error in addImageToPdf:", err);
      resolve(); // Continue without the image
    }
  });
};

export const generatePDF = async (book: Book): Promise<void> => {
  try {
    // Create a new PDF document (A4 format)
    const doc = new jsPDF({
      orientation: "portrait",
      unit: "mm",
      format: "a4"
    });
    
    const pageWidth = doc.internal.pageSize.getWidth();
    const pageHeight = doc.internal.pageSize.getHeight();
    const margin = 20; // margin in mm
    const contentWidth = pageWidth - (margin * 2);
    
    // Add cover page
    if (book.cover.imageUrl) {
      try {
        await addImageToPdf(doc, book.cover.imageUrl, 0, 0, pageWidth, pageHeight);
        
        // Add semi-transparent overlay for better text visibility
        doc.setFillColor(0, 0, 0);
        doc.setDrawColor(0, 0, 0);
        // Create semi-transparent overlay
        doc.setFillColor(20, 20, 20);
        doc.rect(0, 0, pageWidth, pageHeight, "F");
      } catch (err) {
        console.error("Error adding cover image:", err);
      }
    }
    
    // Set font styles for cover
    doc.setTextColor(255, 255, 255);
    doc.setFont("helvetica", "bold");
    doc.setFontSize(24);
    doc.text(book.cover.title, pageWidth / 2, 60, { align: "center" });
    
    doc.setFontSize(16);
    doc.setFont("helvetica", "italic");
    doc.text(book.cover.subtitle, pageWidth / 2, 80, { align: "center" });
    
    // Add central image if available
    if (book.cover.centralImageUrl) {
      try {
        await addImageToPdf(doc, book.cover.centralImageUrl, pageWidth / 2 - 30, 100, 60, 60);
      } catch (err) {
        console.error("Error adding central cover image:", err);
      }
    }
    
    doc.setFont("helvetica", "normal");
    doc.setFontSize(12);
    doc.text("Generated by AI", pageWidth / 2, pageHeight - 40, { align: "center" });
    doc.text(new Date().toLocaleDateString("en-US", { year: "numeric", month: "long" }), pageWidth / 2, pageHeight - 30, { align: "center" });
    
    // Add table of contents
    doc.addPage();
    doc.setTextColor(0, 0, 0); // Reset text color to black
    doc.setFont("helvetica", "bold");
    doc.setFontSize(18);
    doc.text("Table of Contents", margin, margin);
    
    doc.setFont("helvetica", "normal");
    doc.setFontSize(12);
    
    let yPosition = 40;
    book.chapters.forEach((chapter) => {
      doc.text(`Chapter ${chapter.number}: ${chapter.title}`, margin, yPosition);
      yPosition += 10;
      
      // Add dotted line
      if (yPosition < pageHeight - margin) {
        doc.setDrawColor(200, 200, 200);
        doc.setLineWidth(0.1);
        doc.line(margin, yPosition - 5, pageWidth - margin, yPosition - 5);
      }
    });
    
    // Process all chapters and their pages
    for (let c = 0; c < book.chapters.length; c++) {
      const chapter = book.chapters[c];
      
      for (let p = 0; p < chapter.pages.length; p++) {
        const page = chapter.pages[p];
        doc.addPage();
        let currentY = margin;
        
        // Add chapter title and potentially image
        if (page.isChapterStart) {
          doc.setFont("helvetica", "bold");
          doc.setFontSize(18);
          doc.text(`Chapter ${chapter.number}: ${chapter.title}`, margin, currentY);
          currentY += 10;
          
          doc.setFont("helvetica", "normal");
          doc.setFontSize(12);
          
          // Add chapter image if available
          if (page.imageUrl) {
            try {
              // Add the chapter image
              const imageHeight = 50; // Height in mm
              currentY += 10;
              await addImageToPdf(doc, page.imageUrl, margin, currentY, contentWidth, imageHeight);
              currentY += imageHeight + 10; // Move Y position past the image + some padding
            } catch (err) {
              console.error("Error adding chapter image:", err);
            }
          }
        }
        
        // Convert HTML content to plain text
        const tempElement = document.createElement("div");
        tempElement.innerHTML = page.content;
        const textContent = tempElement.textContent || tempElement.innerText;
        
        // Split text into lines to fit in PDF
        const textLines = doc.splitTextToSize(textContent, contentWidth);
        
        // Add text with word wrapping
        const textHeight = doc.getTextDimensions(textLines).h;
        if (currentY + textHeight > pageHeight - margin) {
          // If text would overflow, add a new page
          doc.addPage();
          currentY = margin;
        }
        doc.text(textLines, margin, currentY);
      }
    }
    
    // Save the PDF
    doc.save(`${book.cover.title.replace(/\s+/g, "_")}.pdf`);
    
  } catch (error) {
    console.error("Error generating PDF:", error);
    toast({
      title: "PDF Generation Failed",
      description: "There was an error creating your PDF. Please try again.",
      variant: "destructive",
    });
  }
};
